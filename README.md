# pyTestHarness
## The Idea

Testing code should be easy. The functionality required to launch, parse and perform verification should be light-weight and simple to migrate into existing projects. pyTestHarness supports testing of sequential and MPI-parallel applications. Tests can be performed locally, or submitted via a batch queuing system (e.g. PBS, LSF, Slurm or LoadLeveler).

## Key Concepts

pyTestHarness (pth) provides:

* An object to define a test. A "test" consists of:
(i) a textual name;
(ii) one or more executables;
(iii) a number of MPI ranks (1 for serial execution)
(iii) a text file containing the expected output;
(iv) a method to compare any output generated by the test (e.g. from stdout or another output file)
* A set of tools to parse / filter and query text files for verification purposes
* A "harness" object to quickly define and process a set of tests
* Internally, a "launcher" object to manage launching a serial (or MPI) test locally, or via a batch queuing system

## How do I use this ?

1. pyTestHarness depends on Python 3 (or Python 2.4+) and numpy

2. When using Python 3, it is highly recommended you set the environment variable PYTHONUNBUFFERED, e.g.
```export PYTHONUNBUFFERED```

3. Make sure you modify your PYTHONPATH environment variable to include the directory ```${PWD}/lib``` (relative to this README file)

## Examples

Note: the tests themselves may _fail_ in the following examples. This is to
demonstrate how differences from expected output are reported, and doesn't mean
that the test harness itself isn't working!

### Basic testing of serial applications using the test harness ###

#### Examples 1 and 4
Features:

1. comparison with data in a file;
2. multiple tests;
3. report summary and error log files

Execute the test(s):

```
	cd example1;
	./pth_example1.py
```
```
	cd example4;
	./pth_example4.py
```

#### Example 2
Features:
1. tests which are defined in separate directories;
2. Selecting a subset of tests with with `-t`

```
	cd example2
	./pth_example2.py
  ./pth_example2.p -l         # list all registered tests
	./pth_example2.py -t test1  # can select multiple tests with -t test1,test2
```

### Parallel tests using a PETSc code

#### Example 3
Requires the environment variables ```PETSC_DIR``` and ```PETSC_ARCH``` to be defined. Execute the test:

Features:
1. test defined using an MPI parallel application;
2. test submission through a batch/queuing system

```
	cd example3;
	python pth_example3.py
```

### Defining a test which doesn't depend on an expected output file
#### Example 5
```
	cd example5
	python pth_example5.py
```

### Deleting test output
Generated test output may be deleted by supplying the `-p` option.
```
	cd example5
	python pth_example5.py
  python pth_example5.ph -p
```

### Running tests in dedicated "sandbox" directories
#### Example 6
Each test may be run in a "sandbox" directory using `-s`, useful to run tests which (may) produce identically-named output files.
```
  cd example6
  ./pth_example6.py -s
  ./pth_example6.py -s -p        # remove output
```

### Running multiple executables
#### Example 7
The `execute` field for a `Test` may be a list.
This example executes the same executable twice:
```
  cd example7
  python pth_example7.py
```

## Tips for building tests

* The verification process involves parsing expected output and searching for keywords. If your output generates strings requiring escape characters, for example the string "|a.b|_2", the keyword provided to pyTestHarness needs to be expressed as "\|a.b\|\_2". This is awkward so we recommend using the regular expression utilities which provide a method to add the backslash automatically. E.g.
```
#!/usr/bin/env python

import re
keyword = re.escape("|a.b|_2")
```
